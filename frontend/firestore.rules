rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    function isSignedIn() {
      return request.auth != null;
    }

    function authRole() {
      return request.auth != null && request.auth.token.role is string
        ? lower(request.auth.token.role)
        : null;
    }

    function isAdmin() {
      return authRole() == 'admin';
    }

    function isTeacher() {
      return authRole() == 'teacher';
    }

    function isStudent() {
      return authRole() == 'student';
    }

    function staffCanAccess() {
      return isSignedIn() && (isAdmin() || isTeacher());
    }

    function lowerAuthEmail() {
      return request.auth != null && request.auth.token.email != null
        ? lower(request.auth.token.email)
        : null;
    }

    // Compare email case-insensitively to reduce login friction
    function requestEmailMatches(resourceData) {
      return request.auth != null && resourceData.email is string && request.auth.token.email is string
        && lower(resourceData.email) == lowerAuthEmail();
    }

    function hasNotificationAccess(resourceData) {
      let targets = resourceData.targets;
      return targets is list && (
        (request.auth != null && request.auth.uid in targets) ||
        (request.auth != null && request.auth.token.email is string && request.auth.token.email in targets) ||
        (lowerAuthEmail() != null && lowerAuthEmail() in targets)
      );
    }

    function hasUserIdForRole(userId, role) {
      let normalizedRole = role is string ? lower(role) : role;
      return (normalizedRole == 'admin' && userId.matches('^A[0-9]+$'))
        || (normalizedRole == 'teacher' && userId.matches('^T[0-9]+$'))
        || (normalizedRole == 'student' && userId.matches('^S[0-9]+$'));
    }

    match /users/{userId} {
      // Staff can get/list; students can get/list only their own record (by email)
      allow get, list: if staffCanAccess() || (isStudent() && requestEmailMatches(resource.data));

      // Creating users is limited to staff; normalize role before validation
      allow create: if staffCanAccess()
        && request.resource.data.role is string
        && hasUserIdForRole(userId, request.resource.data.role);

      // Updating/deleting users is limited to staff; again assume stored role is lowercase
      allow update, delete: if staffCanAccess()
        && resource.data.role is string
        && hasUserIdForRole(userId, resource.data.role);
    }

    match /classes/{classId} {
      // Staff can fully manage classes
      allow read, write: if staffCanAccess();

      // Students can see classes (read) as long as theyâ€™re signed in
      allow get, list: if isStudent() && isSignedIn();
    }

    match /attendance/{attendanceId} {
      // Staff can fully manage attendance
      allow read, write: if staffCanAccess();

      // Students can only read their own attendance records
      allow get, list: if isStudent() && isSignedIn()
        && (
          (resource.data.studentID != null && resource.data.studentID == request.auth.uid) ||
          (resource.data.studentId != null && resource.data.studentId == request.auth.uid) ||
          requestEmailMatches(resource.data)
        );
    }

    match /notifications/{notificationId} {
      // Users can read notifications that target them (by uid or email)
      allow get, list: if isSignedIn() && hasNotificationAccess(resource.data);

      // Only allow very controlled updates (e.g., marking read)
      allow update: if isSignedIn() && hasNotificationAccess(resource.data)
        && request.resource.data.userId == resource.data.userId
        && request.resource.data.type == resource.data.type
        && request.resource.data.channel == resource.data.channel
        && request.resource.data.surfaceTargets == resource.data.surfaceTargets
        && request.resource.data.dedupeKey == resource.data.dedupeKey
        && request.resource.data.targets == resource.data.targets
        && request.resource.data.payload == resource.data.payload
        && request.resource.data.title == resource.data.title
        && request.resource.data.message == resource.data.message
        && request.resource.data.tone == resource.data.tone
        && request.resource.data.actionLabel == resource.data.actionLabel
        && request.resource.data.actionHref == resource.data.actionHref
        && request.resource.data.toast == resource.data.toast
        && request.resource.data.banner == resource.data.banner
        && request.resource.data.userEmail == resource.data.userEmail
        && request.resource.data.read is bool
        && request.resource.data.updatedAt is timestamp
        && (!('dismissedSurfaces' in request.resource.data) || request.resource.data.dismissedSurfaces is map)
        && (!('acknowledgedAt' in request.resource.data) || request.resource.data.acknowledgedAt is timestamp);

      allow create, delete: if false;
    }

    match /{document=**} {
      allow read, write: if false;
    }
  }
}
