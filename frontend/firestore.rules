rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    function isSignedIn() {
      return request.auth != null;
    }

    // Assume request.auth.token.role is already stored as lowercase: "admin", "teacher", "student"
    function authRole() {
      return request.auth != null && request.auth.token.role is string
        ? request.auth.token.role
        : null;
    }

    function isAdmin() {
      return authRole() == 'admin';
    }

    function isTeacher() {
      return authRole() == 'teacher';
    }

    function isStudent() {
      return authRole() == 'student';
    }

    function staffCanAccess() {
      return isSignedIn() && (isAdmin() || isTeacher());
    }

    // Simple email comparison; assumes request.auth.token.email matches the stored email exactly
    function requestEmailMatches(resourceData) {
      return request.auth != null
        && resourceData.email is string
        && request.auth.token.email is string
        && resourceData.email == request.auth.token.email;
    }

    function hasNotificationAccess(resourceData) {
      let targets = resourceData.targets;
      return targets is list && (
        (request.auth != null && request.auth.uid in targets) ||
        (request.auth != null && request.auth.token.email is string && request.auth.token.email in targets)
      );
    }

    function hasUserIdForRole(userId, role) {
      return (role == 'admin' && userId.matches('^A[0-9]+$'))
        || (role == 'teacher' && userId.matches('^T[0-9]+$'))
        || (role == 'student' && userId.matches('^S[0-9]+$'));
    }

    match /users/{userId} {
      // Staff can get/list; students can get/list only their own record (by email)
      allow get, list: if staffCanAccess() || (isStudent() && requestEmailMatches(resource.data));

      // Creating users is limited to staff; we assume the role field is already lowercase
      allow create: if staffCanAccess()
        && request.resource.data.role is string
        && hasUserIdForRole(userId, request.resource.data.role);

      // Updating/deleting users is limited to staff; again assume stored role is lowercase
      allow update, delete: if staffCanAccess()
        && resource.data.role is string
        && hasUserIdForRole(userId, resource.data.role);
    }

    match /classes/{classId} {
      // Staff can fully manage classes
      allow read, write: if staffCanAccess();

      // Students can see classes (read) as long as theyâ€™re signed in
      allow get, list: if isStudent() && isSignedIn();
    }

    match /attendance/{attendanceId} {
      // Staff can fully manage attendance
      allow read, write: if staffCanAccess();

      // Students can only read their own attendance records
      allow get, list: if isStudent() && isSignedIn()
        && (
          (resource.data.studentID != null && resource.data.studentID == request.auth.uid) ||
          (resource.data.studentId != null && resource.data.studentId == request.auth.uid) ||
          requestEmailMatches(resource.data)
        );
    }

    match /notifications/{notificationId} {
      // Users can read notifications that target them (by uid or email)
      allow get, list: if isSignedIn() && hasNotificationAccess(resource.data);

      // Only allow very controlled updates (e.g., marking read)
      allow update: if isSignedIn() && hasNotificationAccess(resource.data)
        && request.resource.data.userId == resource.data.userId
        && request.resource.data.type == resource.data.type
        &&
